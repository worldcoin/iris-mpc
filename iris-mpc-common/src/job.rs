use crate::config::Config;
use crate::helpers::batch_sync::{
    get_batch_sync_entries, get_own_batch_sync_entries, BatchSyncEntriesResult,
};
use crate::{
    galois_engine::degree4::{GaloisRingIrisCodeShare, GaloisRingTrimmedMaskCodeShare},
    helpers::{
        statistics::BucketStatistics,
        sync::{Modification, ModificationKey},
    },
};
use core::fmt;
use eyre::{eyre, Result};
use serde::{Deserialize, Serialize};
use std::sync::{LazyLock, Mutex};
use std::{
    collections::HashMap,
    fmt::{Display, Formatter},
    future::Future,
};

pub static CURRENT_BATCH_SHA: LazyLock<Mutex<[u8; 32]>> = LazyLock::new(|| Mutex::new([0; 32]));
pub static CURRENT_BATCH_VALID_ENTRIES: LazyLock<Mutex<Vec<bool>>> =
    LazyLock::new(|| Mutex::new(Vec::new()));

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct IrisQueryBatchEntries {
    pub code: Vec<GaloisRingIrisCodeShare>,
    pub mask: Vec<GaloisRingTrimmedMaskCodeShare>,
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BatchMetadata {
    pub node_id: String,
    pub trace_id: String,
    pub span_id: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GaloisSharesBothSides {
    pub code_left: GaloisRingIrisCodeShare,
    pub mask_left: GaloisRingTrimmedMaskCodeShare,
    pub code_right: GaloisRingIrisCodeShare,
    pub mask_right: GaloisRingTrimmedMaskCodeShare,
}

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct BatchQuery {
    /// The original order of the requests before grouping them by type in this batch structure.
    pub requests_order: Vec<RequestIndex>,

    // Enrollment and reauth specific fields

    // UUIDs generated by orb, unique per signup request
    // NOTE: these need to map to the request ID in the ServerJobResult
    pub request_ids: Vec<String>,
    // Request types, e.g. uniqueness, reauth, deletion, for now we will only handle uniqueness
    // message types
    pub request_types: Vec<String>,
    // Metadata for each request - just needs to be sent back for each requestID
    // This is used for logging and tracing purposes
    pub metadata: Vec<BatchMetadata>,

    // Iris queries from the request for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,

    // Iris queries from the request with rotations for in-memory database.
    pub left_iris_rotated_requests: IrisQueryBatchEntries,
    pub right_iris_rotated_requests: IrisQueryBatchEntries,

    // Iris queries from the request with Lagrange interpolations
    pub left_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_iris_interpolated_requests: IrisQueryBatchEntries,

    // Iris queries for the mirrored case of the request with Langrange interpolations. Used for
    // mirror attack detection.
    pub left_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,

    // array of indexes at which to use OR rule comparison
    pub or_rule_indices: Vec<Vec<u32>>,
    // This is temporary and won't be used once HNSW goes live
    pub luc_lookback_records: usize,

    // In case a request is unable to be processed, e.g. shares cannot be decrypted
    // invalid entries are filled up with dummy shares/masks
    // Also is synced to ensure each node has the same valid entries
    pub valid_entries: Vec<bool>,

    // Skip persistence for not maintaining persistence
    // This is used to skip the persistence of the iris shares in the database
    // if it is not a match. This is for testing the flow
    pub skip_persistence: Vec<bool>,

    // Only reauth specific fields
    // Map from reauth request id to the index of the target entry to be matched
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_use_or_rule: HashMap<String, bool>,

    // Only deletion specific fields
    pub deletion_requests_indices: Vec<u32>, // 0-indexed indices of entries to be deleted
    pub deletion_requests_metadata: Vec<BatchMetadata>,

    // Keeping track of updates & deletions for sync mechanism. Mapping: ModificationKey -> Modification
    // Used for roll forward in the case of needing to re-run mutations
    pub modifications: HashMap<ModificationKey, Modification>,

    // SNS message ids to assert identical batch processing across parties
    pub sns_message_ids: Vec<String>,

    // Reset Update specific fields
    pub reset_update_indices: Vec<u32>,
    pub reset_update_request_ids: Vec<String>,
    pub reset_update_shares: Vec<GaloisSharesBothSides>,

    // Boolean value for mirror attack detection enabled
    pub full_face_mirror_attacks_detection_enabled: bool,
}

impl BatchQuery {
    /// Add a Uniqueness, Reauth, or Reset Check request to the batch.
    pub fn push_matching_request(
        &mut self,
        sns_message_id: String,
        request_id: String,
        request_type: &str,
        metadata: BatchMetadata,
        or_rule_indices: Vec<u32>,
        skip_persistence: bool,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order
            .push(RequestIndex::UniqueReauthResetCheck(self.request_ids.len()));

        self.request_ids.push(request_id);
        self.request_types.push(request_type.to_string());
        self.metadata.push(metadata);
        self.or_rule_indices.push(or_rule_indices);
        self.skip_persistence.push(skip_persistence);
    }

    /// Add a Deletion request to the batch.
    pub fn push_deletion_request(
        &mut self,
        sns_message_id: String,
        deletion_0_index: u32,
        metadata: BatchMetadata,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order
            .push(RequestIndex::Deletion(self.deletion_requests_indices.len()));

        self.deletion_requests_indices.push(deletion_0_index);
        self.deletion_requests_metadata.push(metadata);
    }

    /// Add a Reset Update request to the batch.
    pub fn push_reset_update_request(
        &mut self,
        sns_message_id: String,
        request_id: String,
        reset_update_0_index: u32,
        shares: GaloisSharesBothSides,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order.push(RequestIndex::ResetUpdate(
            self.reset_update_request_ids.len(),
        ));

        self.reset_update_request_ids.push(request_id);
        self.reset_update_indices.push(reset_update_0_index);
        self.reset_update_shares.push(shares);
    }
    pub async fn sync_batch_entries(&mut self, config: &Config) -> Result<(), eyre::Error> {
        let own_sync_state = get_own_batch_sync_entries().await;
        let batch_sync_entries =
            get_batch_sync_entries(config, Some(own_sync_state.clone())).await?;

        let batch_sync_entries_result =
            BatchSyncEntriesResult::new(own_sync_state.clone(), batch_sync_entries);

        if !batch_sync_entries_result.sha_matches() {
            tracing::error!(
                "Batch sync entries SHA mismatch: own batch SHAs: {}, all SHAs: {}",
                batch_sync_entries_result.own_sha_pretty(),
                batch_sync_entries_result.all_shas_pretty()
            );
            return Err(eyre!("Batch sync entries SHA mismatch"));
        }
        tracing::info!(
            "Batch sync entries SHA match: {}",
            batch_sync_entries_result.all_shas_pretty()
        );

        let valid_entries = batch_sync_entries_result.valid_entries();
        tracing::info!(
            "Batch sync entries valid entries: {}",
            valid_entries.clone().into_iter().filter(|b| *b).count()
        );

        if !valid_entries.eq(&own_sync_state.clone().valid_entries) {
            tracing::warn!(
                "Valid entries from sync does not equal own valid entries: (own) {}, (sync) {}",
                own_sync_state
                    .valid_entries
                    .clone()
                    .into_iter()
                    .filter(|b| *b)
                    .count(),
                valid_entries.clone().into_iter().filter(|b| *b).count()
            );
            self.valid_entries = valid_entries.clone();
        }
        Ok(())
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum RequestIndex {
    /// Request types: Uniqueness, Reauth, Reset Check.
    /// Fields: request_ids, request_types, *_iris_*, ...
    UniqueReauthResetCheck(usize),
    /// Request type: Deletion.
    /// Fields: deletion_requests_*
    Deletion(usize),
    /// Request type: Reset Update.
    /// Fields: reset_update_*
    ResetUpdate(usize),
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct ServerJobResult<A = ()> {
    pub merged_results: Vec<u32>,
    // As defined in the BatchQuery - should be ordered in the same way
    pub request_ids: Vec<String>,
    // As defined in the BatchQuery
    pub request_types: Vec<String>,
    // As defined in the BatchQuery
    pub metadata: Vec<BatchMetadata>,
    // Boolean array to indicate if the query was unique or not
    pub matches: Vec<bool>,
    // Boolean array to indicate if the query was unique which includes the matches that were not
    // entered into the DB
    pub matches_with_skip_persistence: Vec<bool>,
    // For each query, the serial ids to which the query matched to
    pub match_ids: Vec<Vec<u32>>,
    // For each query, the serial ids to which the query matched to for full face mirror attacks
    pub full_face_mirror_match_ids: Vec<Vec<u32>>,
    // For each query, the serial ids to which the query partially matched to
    // on the left eye. These include also potential match ids - note that a match
    // is included in the match_ids if it matches on both side (AND rule)
    // In GPU context, we limit these to 2048 entries
    pub partial_match_ids_left: Vec<Vec<u32>>,
    // same, but for the right side
    pub partial_match_ids_right: Vec<Vec<u32>>,
    // For each query, for each partial match ID on the left eye, the list of rotations that matched
    pub partial_match_rotation_indices_left: Vec<Vec<Vec<i8>>>,
    // For each query, for each partial match ID on the right eye, the list of rotations that matched
    pub partial_match_rotation_indices_right: Vec<Vec<Vec<i8>>>,
    // same but for full face mirror attacks
    pub full_face_mirror_partial_match_ids_left: Vec<Vec<u32>>,
    pub full_face_mirror_partial_match_ids_right: Vec<Vec<u32>>,
    // The total count of matches for each query on the left eye. This is included
    // because taking the len(partial_match_ids_left) is not enough: we truncate the
    // partial matches to 2048 entries, so we want to know how many total matches there are
    pub partial_match_counters_left: Vec<usize>,
    // Same, but for the right side
    pub partial_match_counters_right: Vec<usize>,
    // Same, but for mirror attacks
    pub full_face_mirror_partial_match_counters_left: Vec<usize>,
    pub full_face_mirror_partial_match_counters_right: Vec<usize>,
    // Original iris shares left for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,
    // Deleted ids, this can be ignored on the first iterations of HNSW
    pub deleted_ids: Vec<u32>,
    // For each query, a set of serial ids that were matched *within* the same batch
    pub matched_batch_request_ids: Vec<Vec<String>>,
    // See struct definition for more details
    pub anonymized_bucket_statistics_left: BucketStatistics,
    pub anonymized_bucket_statistics_right: BucketStatistics,
    // Mirror orientation bucket statistics
    pub anonymized_bucket_statistics_left_mirror: BucketStatistics,
    pub anonymized_bucket_statistics_right_mirror: BucketStatistics,
    // Reauth results, this can be ignored on the first iterations of HNSW
    pub successful_reauths: Vec<bool>, // true if request type is reauth and it's successful
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_or_rule_used: HashMap<String, bool>,
    // Keeping track of updates & deletions for sync mechanism. Mapping: ModificationKey -> Modification
    // Used for roll forward in the case of needing to r-run mutations
    pub modifications: HashMap<ModificationKey, Modification>,
    // Actor-specific data (e.g. graph mutations).
    pub actor_data: A,
    // Reset Update specific fields
    pub reset_update_indices: Vec<u32>,
    pub reset_update_request_ids: Vec<String>,
    pub reset_update_shares: Vec<GaloisSharesBothSides>,
    // Boolean array to indicate if the query is a full face mirror attack attempt.
    pub full_face_mirror_attack_detected: Vec<bool>,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum Eye {
    #[default]
    Left,
    Right,
}

impl Eye {
    pub fn other(&self) -> Self {
        match self {
            Self::Left => Self::Right,
            Self::Right => Self::Left,
        }
    }
}

impl Display for Eye {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
        }
    }
}
pub trait JobSubmissionHandle {
    type A;

    #[allow(async_fn_in_trait)]
    async fn submit_batch_query(
        &mut self,
        batch: BatchQuery,
    ) -> impl Future<Output = Result<ServerJobResult<Self::A>>>;
}
