use crate::{
    galois_engine::degree4::{GaloisRingIrisCodeShare, GaloisRingTrimmedMaskCodeShare},
    helpers::{statistics::BucketStatistics, sync::Modification},
};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, future::Future};

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct IrisQueryBatchEntries {
    pub code: Vec<GaloisRingIrisCodeShare>,
    pub mask: Vec<GaloisRingTrimmedMaskCodeShare>,
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BatchMetadata {
    pub node_id: String,
    pub trace_id: String,
    pub span_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct BatchQuery {
    // Enrollment and reauth specific fields

    // UUIDs generated by orb, unique per signup request
    // NOTE: these need to map to the request ID in the ServerJobResult
    pub request_ids: Vec<String>,
    // Request types, e.g. uniqueness, reauth, deletion, for now we will only handle uniqueness
    // message types
    pub request_types: Vec<String>,
    // Metadata for each request - just needs to be sent back for each requestID
    // This is used for logging and tracing purposes
    pub metadata: Vec<BatchMetadata>,

    // Iris queries from the request for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,

    // Iris queries from the request with rotations for in-memory database.
    pub left_iris_rotated_requests: IrisQueryBatchEntries,
    pub right_iris_rotated_requests: IrisQueryBatchEntries,

    // Iris queries from the request with Lagrange interpolations
    pub left_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_iris_interpolated_requests: IrisQueryBatchEntries,

    // Iris queries for the mirrored case of the request with Langrange interpolations. Used for
    // mirror attack detection.
    pub left_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,

    // array of indexes at which to use OR rule comparison
    pub or_rule_indices: Vec<Vec<u32>>,
    // This is temporary and won't be used once HNSW goes live
    pub luc_lookback_records: usize,

    // In case a request is unable to be processed, e.g. shares cannot be decrypted
    // invalid entries are filled up with dummy shares/masks
    // Also is synced to ensure each node has the same valid entries
    pub valid_entries: Vec<bool>,

    // Skip persistence for not maintaining persistence
    // This is used to skip the persistence of the iris shares in the database
    // if it is not a match. This is for testing the flow
    pub skip_persistence: Vec<bool>,

    // Only reauth specific fields
    // Map from reauth request id to the index of the target entry to be matched
    // These can be ignored on the first iterations of HNSW
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_use_or_rule: HashMap<String, bool>,

    // Only deletion specific fields
    // These can be ignored on the first iterations of HNSW
    pub deletion_requests_indices: Vec<u32>, // 0-indexed indices of entries to be deleted
    pub deletion_requests_metadata: Vec<BatchMetadata>,

    // Keeping track of updates & deletions for sync mechanism. Mapping: Serial id -> Modification
    // Used for roll forward in the case of needing to r-run mutations
    pub modifications: HashMap<u32, Modification>,

    // SNS message ids to assert identical batch processing across parties
    pub sns_message_ids: Vec<String>,
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct ServerJobResult<A = ()> {
    pub merged_results: Vec<u32>,
    // As defined in the BatchQuery - should be ordered in the same way
    pub request_ids: Vec<String>,
    // As defined in the BatchQuery
    pub request_types: Vec<String>,
    // As defined in the BatchQuery
    pub metadata: Vec<BatchMetadata>,
    // Boolean array to indicate if the query was unique or not
    pub matches: Vec<bool>,
    // Boolean array to indicate if the query was unique which includes the matches that were not
    // entered into the DB
    pub matches_with_skip_persistence: Vec<bool>,

    // For each query, the serial ids to which the query matched to
    pub match_ids: Vec<Vec<u32>>,
    // For each query, the serial ids to which the query partially matched to
    // on the left eye. These include also potential match ids - note that a match
    // is included in the match_ids if it matches on both side (AND rule)
    // In GPU context, we limit these to 2048 entries
    pub partial_match_ids_left: Vec<Vec<u32>>,
    // same, but for the right side
    pub partial_match_ids_right: Vec<Vec<u32>>,
    // The total count of matches for each query on the left eye. This is included
    // because taking the len(partial_match_ids_left) is not enough: we truncate the
    // partial matches to 2048 entries, so we want to know how many total matches there are
    pub partial_match_counters_left: Vec<usize>,
    // Same, but for the right side
    pub partial_match_counters_right: Vec<usize>,
    // Original iris shares left for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,
    // Deleted ids, this can be ignored on the first iterations of HNSW
    pub deleted_ids: Vec<u32>,
    // For each query, a set of serial ids that were matched *within* the same batch
    pub matched_batch_request_ids: Vec<Vec<String>>,
    // See struct definition for more details
    pub anonymized_bucket_statistics_left: BucketStatistics,
    pub anonymized_bucket_statistics_right: BucketStatistics,
    // Reauth results, this can be ignored on the first iterations of HNSW
    pub successful_reauths: Vec<bool>, // true if request type is reauth and it's successful
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_or_rule_used: HashMap<String, bool>,
    // Keeping track of updates & deletions for sync mechanism. Mapping: Serial id -> Modification
    // Used for roll forward in the case of needing to r-run mutations
    pub modifications: HashMap<u32, Modification>,
    /// Actor-specific data (e.g. graph mutations).
    pub actor_data: A,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum Eye {
    #[default]
    Left,
    Right,
}

pub trait JobSubmissionHandle {
    type A;

    #[allow(async_fn_in_trait)]
    async fn submit_batch_query(
        &mut self,
        batch: BatchQuery,
    ) -> impl Future<Output = ServerJobResult<Self::A>>;
}
