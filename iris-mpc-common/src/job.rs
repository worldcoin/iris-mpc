use crate::config::Config;
use crate::galois_engine::degree4::GaloisShares;
use crate::helpers::batch_sync::{
    get_batch_sync_entries, get_own_batch_sync_entries, BatchSyncEntriesResult,
};
use crate::{
    galois_engine::degree4::{GaloisRingIrisCodeShare, GaloisRingTrimmedMaskCodeShare},
    helpers::{
        statistics::BucketStatistics,
        sync::{Modification, ModificationKey},
    },
    ROTATIONS,
};
use core::fmt;
use eyre::{eyre, Result};
use serde::{Deserialize, Serialize};
use std::sync::{LazyLock, Mutex};
use std::{
    collections::HashMap,
    fmt::{Display, Formatter},
    future::Future,
};

pub static CURRENT_BATCH_SHA: LazyLock<Mutex<[u8; 32]>> = LazyLock::new(|| Mutex::new([0; 32]));
pub static CURRENT_BATCH_VALID_ENTRIES: LazyLock<Mutex<Vec<bool>>> =
    LazyLock::new(|| Mutex::new(Vec::new()));

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct IrisQueryBatchEntries {
    pub code: Vec<GaloisRingIrisCodeShare>,
    pub mask: Vec<GaloisRingTrimmedMaskCodeShare>,
}
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
pub struct BatchMetadata {
    pub node_id: String,
    pub trace_id: String,
    pub span_id: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GaloisSharesBothSides {
    pub code_left: GaloisRingIrisCodeShare,
    pub mask_left: GaloisRingTrimmedMaskCodeShare,
    pub code_right: GaloisRingIrisCodeShare,
    pub mask_right: GaloisRingTrimmedMaskCodeShare,
}

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct BatchQuery {
    /// The original order of the requests before grouping them by type in this batch structure.
    pub requests_order: Vec<RequestIndex>,

    // Enrollment and reauth specific fields

    // UUIDs generated by orb, unique per signup request
    // NOTE: these need to map to the request ID in the ServerJobResult
    pub request_ids: Vec<String>,
    // Request types, e.g. uniqueness, reauth, deletion, for now we will only handle uniqueness
    // message types
    pub request_types: Vec<String>,
    // Metadata for each request - just needs to be sent back for each requestID
    // This is used for logging and tracing purposes
    pub metadata: Vec<BatchMetadata>,

    // Iris queries from the request for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,

    // Iris queries from the request with rotations for in-memory database.
    pub left_iris_rotated_requests: IrisQueryBatchEntries,
    pub right_iris_rotated_requests: IrisQueryBatchEntries,

    // Iris queries from the request with Lagrange interpolations
    pub left_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_iris_interpolated_requests: IrisQueryBatchEntries,

    // Iris queries for the mirrored case of the request with Langrange interpolations. Used for
    // mirror attack detection.
    pub left_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,
    pub right_mirrored_iris_interpolated_requests: IrisQueryBatchEntries,

    // array of indexes at which to use OR rule comparison
    pub or_rule_indices: Vec<Vec<u32>>,
    // This is temporary and won't be used once HNSW goes live
    pub luc_lookback_records: usize,

    // In case a request is unable to be processed, e.g. shares cannot be decrypted
    // invalid entries are filled up with dummy shares/masks
    // Also is synced to ensure each node has the same valid entries
    pub valid_entries: Vec<bool>,

    // Skip persistence for not maintaining persistence
    // This is used to skip the persistence of the iris shares in the database
    // if it is not a match. This is for testing the flow
    pub skip_persistence: Vec<bool>,

    // Only reauth specific fields
    // Map from reauth request id to the index of the target entry to be matched
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_use_or_rule: HashMap<String, bool>,

    // Only deletion specific fields
    pub deletion_requests_indices: Vec<u32>, // 0-indexed indices of entries to be deleted
    pub deletion_requests_metadata: Vec<BatchMetadata>,

    // Keeping track of updates & deletions for sync mechanism. Mapping: ModificationKey -> Modification
    // Used for roll forward in the case of needing to re-run mutations
    pub modifications: HashMap<ModificationKey, Modification>,

    // SNS message ids to assert identical batch processing across parties
    pub sns_message_ids: Vec<String>,

    // Reset Update specific fields
    pub reset_update_indices: Vec<u32>,
    pub reset_update_request_ids: Vec<String>,
    pub reset_update_shares: Vec<GaloisSharesBothSides>,

    // Boolean value for mirror attack detection enabled
    pub full_face_mirror_attacks_detection_enabled: bool,
}

impl BatchQuery {
    /// Add a Uniqueness, Reauth, or Reset Check request to the batch.
    /// Must be followed by a call to `push_matching_request_shares` to set the shares.
    pub fn push_matching_request(
        &mut self,
        sns_message_id: String,
        request_id: String,
        request_type: &str,
        metadata: BatchMetadata,
        or_rule_indices: Vec<u32>,
        skip_persistence: bool,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order
            .push(RequestIndex::UniqueReauthResetCheck(self.request_ids.len()));

        self.request_ids.push(request_id);
        self.request_types.push(request_type.to_string());
        self.metadata.push(metadata);
        self.or_rule_indices.push(or_rule_indices);
        self.skip_persistence.push(skip_persistence);
    }

    /// Add a Deletion request to the batch.
    pub fn push_deletion_request(
        &mut self,
        sns_message_id: String,
        deletion_0_index: u32,
        metadata: BatchMetadata,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order
            .push(RequestIndex::Deletion(self.deletion_requests_indices.len()));

        self.deletion_requests_indices.push(deletion_0_index);
        self.deletion_requests_metadata.push(metadata);
    }

    /// Add a Reset Update request to the batch.
    pub fn push_reset_update_request(
        &mut self,
        sns_message_id: String,
        request_id: String,
        reset_update_0_index: u32,
        shares: GaloisSharesBothSides,
    ) {
        self.sns_message_ids.push(sns_message_id);
        self.requests_order.push(RequestIndex::ResetUpdate(
            self.reset_update_request_ids.len(),
        ));

        self.reset_update_request_ids.push(request_id);
        self.reset_update_indices.push(reset_update_0_index);
        self.reset_update_shares.push(shares);
    }

    pub fn push_matching_request_shares(
        &mut self,
        share_left: GaloisShares,
        share_right: GaloisShares,
        valid: bool,
    ) {
        self.left_iris_requests.code.push(share_left.code);
        self.left_iris_requests.mask.push(share_left.mask);
        self.left_iris_rotated_requests
            .code
            .extend(share_left.code_rotated);
        self.left_iris_rotated_requests
            .mask
            .extend(share_left.mask_rotated);
        self.left_iris_interpolated_requests
            .code
            .extend(share_left.code_interpolated);
        self.left_iris_interpolated_requests
            .mask
            .extend(share_left.mask_interpolated);

        self.right_iris_requests.code.push(share_right.code);
        self.right_iris_requests.mask.push(share_right.mask);
        self.right_iris_rotated_requests
            .code
            .extend(share_right.code_rotated);
        self.right_iris_rotated_requests
            .mask
            .extend(share_right.mask_rotated);
        self.right_iris_interpolated_requests
            .code
            .extend(share_right.code_interpolated);
        self.right_iris_interpolated_requests
            .mask
            .extend(share_right.mask_interpolated);

        self.left_mirrored_iris_interpolated_requests
            .code
            .extend(share_left.code_mirrored);
        self.left_mirrored_iris_interpolated_requests
            .mask
            .extend(share_left.mask_mirrored);
        self.right_mirrored_iris_interpolated_requests
            .code
            .extend(share_right.code_mirrored);
        self.right_mirrored_iris_interpolated_requests
            .mask
            .extend(share_right.mask_mirrored);

        self.valid_entries.push(valid);
    }

    pub async fn sync_batch_entries(&mut self, config: &Config) -> Result<(), eyre::Error> {
        let own_sync_state = get_own_batch_sync_entries().await;
        let batch_sync_entries =
            get_batch_sync_entries(config, Some(own_sync_state.clone())).await?;

        let batch_sync_entries_result =
            BatchSyncEntriesResult::new(own_sync_state.clone(), batch_sync_entries);

        if !batch_sync_entries_result.sha_matches() {
            tracing::error!(
                "Batch sync entries SHA mismatch: own batch SHAs: {}, all SHAs: {}",
                batch_sync_entries_result.own_sha_pretty(),
                batch_sync_entries_result.all_shas_pretty()
            );
            return Err(eyre!("Batch sync entries SHA mismatch"));
        }
        tracing::info!(
            "Batch sync entries SHA match: {}",
            batch_sync_entries_result.all_shas_pretty()
        );

        let valid_entries = batch_sync_entries_result.valid_entries();
        tracing::info!(
            "Batch sync entries valid entries: {}",
            valid_entries.clone().into_iter().filter(|b| *b).count()
        );

        if !valid_entries.eq(&own_sync_state.clone().valid_entries) {
            tracing::warn!(
                "Valid entries from sync does not equal own valid entries: (own) {}, (sync) {}",
                own_sync_state
                    .valid_entries
                    .clone()
                    .into_iter()
                    .filter(|b| *b)
                    .count(),
                valid_entries.clone().into_iter().filter(|b| *b).count()
            );
            self.valid_entries = valid_entries.clone();
        }
        Ok(())
    }

    pub fn retain_valid_entries(&mut self) {
        use RequestIndex::*;
        let valid = self.valid_entries.clone();

        let index_map = (0..valid.len())
            .filter(|old_index| valid[*old_index])
            .enumerate()
            .map(|(new_index, old_index)| (old_index, new_index))
            .collect::<HashMap<usize, usize>>();

        self.requests_order = self
            .requests_order
            .iter()
            .filter_map(|request| match request {
                UniqueReauthResetCheck(old_index) => index_map
                    .get(old_index)
                    .map(|new_index| RequestIndex::UniqueReauthResetCheck(*new_index)),
                _ => Some(*request),
            })
            .collect();

        macro_rules! filter_valid {
            ($data:expr) => {
                $data = $data
                    .iter()
                    .enumerate()
                    .filter(|(i, _)| valid[*i])
                    .map(|(_, v)| v.clone())
                    .collect();
            };
        }

        macro_rules! filter_valid_with_rotations {
            ($data:expr) => {
                $data = $data
                    .chunks(ROTATIONS)
                    .enumerate()
                    .filter(|(i, _)| valid[*i])
                    .flat_map(|(_, chunk)| chunk.iter().cloned())
                    .collect();
            };
        }

        filter_valid!(self.valid_entries);

        // Fields from push_matching_request
        filter_valid!(self.request_ids);
        filter_valid!(self.request_types);
        filter_valid!(self.metadata);
        filter_valid!(self.or_rule_indices);
        filter_valid!(self.skip_persistence);

        // Fields from push_matching_request_shares
        filter_valid!(self.left_iris_requests.code);
        filter_valid!(self.left_iris_requests.mask);
        filter_valid!(self.right_iris_requests.code);
        filter_valid!(self.right_iris_requests.mask);

        filter_valid_with_rotations!(self.left_iris_interpolated_requests.code);
        filter_valid_with_rotations!(self.left_iris_interpolated_requests.mask);
        filter_valid_with_rotations!(self.left_iris_rotated_requests.code);
        filter_valid_with_rotations!(self.left_iris_rotated_requests.mask);
        filter_valid_with_rotations!(self.right_iris_interpolated_requests.code);
        filter_valid_with_rotations!(self.right_iris_interpolated_requests.mask);
        filter_valid_with_rotations!(self.right_iris_rotated_requests.code);
        filter_valid_with_rotations!(self.right_iris_rotated_requests.mask);
        filter_valid_with_rotations!(self.left_mirrored_iris_interpolated_requests.code);
        filter_valid_with_rotations!(self.left_mirrored_iris_interpolated_requests.mask);
        filter_valid_with_rotations!(self.right_mirrored_iris_interpolated_requests.code);
        filter_valid_with_rotations!(self.right_mirrored_iris_interpolated_requests.mask);
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum RequestIndex {
    /// Request types: Uniqueness, Reauth, Reset Check.
    /// Fields: request_ids, request_types, *_iris_*, ...
    UniqueReauthResetCheck(usize),
    /// Request type: Deletion.
    /// Fields: deletion_requests_*
    Deletion(usize),
    /// Request type: Reset Update.
    /// Fields: reset_update_*
    ResetUpdate(usize),
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct ServerJobResult<A = ()> {
    pub merged_results: Vec<u32>,
    // As defined in the BatchQuery - should be ordered in the same way
    pub request_ids: Vec<String>,
    // As defined in the BatchQuery
    pub request_types: Vec<String>,
    // As defined in the BatchQuery
    pub metadata: Vec<BatchMetadata>,
    // Boolean array to indicate if the query was unique or not
    pub matches: Vec<bool>,
    // Boolean array to indicate if the query was unique which includes the matches that were not
    // entered into the DB
    pub matches_with_skip_persistence: Vec<bool>,
    // For each query, the serial ids to which the query matched to
    pub match_ids: Vec<Vec<u32>>,
    // For each query, the serial ids to which the query matched to for full face mirror attacks
    pub full_face_mirror_match_ids: Vec<Vec<u32>>,
    // For each query, the serial ids to which the query partially matched to
    // on the left eye. These include also potential match ids - note that a match
    // is included in the match_ids if it matches on both side (AND rule)
    // In GPU context, we limit these to 2048 entries
    pub partial_match_ids_left: Vec<Vec<u32>>,
    // same, but for the right side
    pub partial_match_ids_right: Vec<Vec<u32>>,
    // For each query, for each partial match ID on the left eye, the list of rotations that matched
    pub partial_match_rotation_indices_left: Vec<Vec<Vec<i8>>>,
    // For each query, for each partial match ID on the right eye, the list of rotations that matched
    pub partial_match_rotation_indices_right: Vec<Vec<Vec<i8>>>,
    // same but for full face mirror attacks
    pub full_face_mirror_partial_match_ids_left: Vec<Vec<u32>>,
    pub full_face_mirror_partial_match_ids_right: Vec<Vec<u32>>,
    // The total count of matches for each query on the left eye. This is included
    // because taking the len(partial_match_ids_left) is not enough: we truncate the
    // partial matches to 2048 entries, so we want to know how many total matches there are
    pub partial_match_counters_left: Vec<usize>,
    // Same, but for the right side
    pub partial_match_counters_right: Vec<usize>,
    // Same, but for mirror attacks
    pub full_face_mirror_partial_match_counters_left: Vec<usize>,
    pub full_face_mirror_partial_match_counters_right: Vec<usize>,
    // Original iris shares left for storage
    pub left_iris_requests: IrisQueryBatchEntries,
    pub right_iris_requests: IrisQueryBatchEntries,
    // Deleted ids, this can be ignored on the first iterations of HNSW
    pub deleted_ids: Vec<u32>,
    // For each query, a set of serial ids that were matched *within* the same batch
    pub matched_batch_request_ids: Vec<Vec<String>>,
    // See struct definition for more details
    pub anonymized_bucket_statistics_left: BucketStatistics,
    pub anonymized_bucket_statistics_right: BucketStatistics,
    // Mirror orientation bucket statistics
    pub anonymized_bucket_statistics_left_mirror: BucketStatistics,
    pub anonymized_bucket_statistics_right_mirror: BucketStatistics,
    // Reauth results, this can be ignored on the first iterations of HNSW
    pub successful_reauths: Vec<bool>, // true if request type is reauth and it's successful
    pub reauth_target_indices: HashMap<String, u32>,
    pub reauth_or_rule_used: HashMap<String, bool>,
    // Keeping track of updates & deletions for sync mechanism. Mapping: ModificationKey -> Modification
    // Used for roll forward in the case of needing to r-run mutations
    pub modifications: HashMap<ModificationKey, Modification>,
    // Actor-specific data (e.g. graph mutations).
    pub actor_data: A,
    // Reset Update specific fields
    pub reset_update_indices: Vec<u32>,
    pub reset_update_request_ids: Vec<String>,
    pub reset_update_shares: Vec<GaloisSharesBothSides>,
    // Boolean array to indicate if the query is a full face mirror attack attempt.
    pub full_face_mirror_attack_detected: Vec<bool>,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum Eye {
    #[default]
    Left,
    Right,
}

impl Eye {
    pub fn other(&self) -> Self {
        match self {
            Self::Left => Self::Right,
            Self::Right => Self::Left,
        }
    }
}

impl Display for Eye {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
        }
    }
}
pub trait JobSubmissionHandle {
    type A;

    #[allow(async_fn_in_trait)]
    async fn submit_batch_query(
        &mut self,
        batch: BatchQuery,
    ) -> impl Future<Output = Result<ServerJobResult<Self::A>>>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        helpers::smpc_request::UNIQUENESS_MESSAGE_TYPE, IRIS_CODE_LENGTH, MASK_CODE_LENGTH,
    };

    #[test]
    fn test_batch_valid_entries() {
        let mut batch_query = BatchQuery::default();

        batch_query.push_deletion_request("deletion_0".to_string(), 0, BatchMetadata::default());

        for i in 0..3 {
            batch_query.push_matching_request(
                format!("uniq_{}", i),
                format!("request_{}", i),
                UNIQUENESS_MESSAGE_TYPE,
                BatchMetadata::default(),
                vec![],
                false,
            );

            let code = GaloisRingIrisCodeShare {
                id: 0,
                coefs: [i as u16; IRIS_CODE_LENGTH],
            };
            let mask = GaloisRingTrimmedMaskCodeShare {
                id: 0,
                coefs: [i as u16; MASK_CODE_LENGTH],
            };
            let shares = GaloisShares {
                code: code.clone(),
                mask: mask.clone(),
                code_rotated: vec![code.clone(); ROTATIONS],
                mask_rotated: vec![mask.clone(); ROTATIONS],
                code_interpolated: vec![code.clone(); ROTATIONS],
                mask_interpolated: vec![mask.clone(); ROTATIONS],
                code_mirrored: vec![code; ROTATIONS],
                mask_mirrored: vec![mask; ROTATIONS],
            };

            batch_query.push_matching_request_shares(shares.clone(), shares, i != 1);
        }

        batch_query.push_deletion_request("deletion_1".to_string(), 0, BatchMetadata::default());

        assert_eq!(batch_query.valid_entries, vec![true, false, true]);

        batch_query.retain_valid_entries();

        // Entry 1 was removed.
        assert_eq!(batch_query.valid_entries, vec![true, true]);
        assert_eq!(batch_query.request_ids, vec!["request_0", "request_2"]);

        // The request order is updated.
        assert_eq!(
            batch_query.requests_order,
            vec![
                RequestIndex::Deletion(0),
                RequestIndex::UniqueReauthResetCheck(0),
                RequestIndex::UniqueReauthResetCheck(1), // Remaped from 2 to 1.
                RequestIndex::Deletion(1),
            ]
        );

        // The codes and masks are filtered.
        assert_eq!(batch_query.left_iris_requests.code.len(), 2);
        assert_eq!(batch_query.left_iris_requests.code[0].coefs[0], 0);
        assert_eq!(batch_query.left_iris_requests.code[1].coefs[0], 2);

        assert_eq!(batch_query.left_iris_requests.mask.len(), 2);
        assert_eq!(batch_query.left_iris_requests.mask[0].coefs[0], 0);
        assert_eq!(batch_query.left_iris_requests.mask[1].coefs[0], 2);

        // The codes and masks with rotations are filtered.
        assert_eq!(
            batch_query.left_iris_rotated_requests.code.len(),
            2 * ROTATIONS
        );
        assert_eq!(batch_query.left_iris_rotated_requests.code[0].coefs[0], 0);
        assert_eq!(
            batch_query.left_iris_rotated_requests.code[ROTATIONS].coefs[0],
            2
        );

        assert_eq!(
            batch_query.left_iris_rotated_requests.mask.len(),
            2 * ROTATIONS
        );
        assert_eq!(batch_query.left_iris_rotated_requests.mask[0].coefs[0], 0);
        assert_eq!(
            batch_query.left_iris_rotated_requests.mask[ROTATIONS].coefs[0],
            2
        );

        // The original SNS message IDs are kept.
        assert_eq!(
            batch_query.sns_message_ids,
            vec!["deletion_0", "uniq_0", "uniq_1", "uniq_2", "deletion_1"]
        );
    }
}
