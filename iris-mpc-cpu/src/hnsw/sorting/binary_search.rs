#[inline(always)]
fn midpoint(left: usize, right: usize) -> usize {
    left + (right - left) / 2
}

/// Represents an ongoing binary search to identify the insertion index of a
/// query `Value` within a sorted array.  The next pair of values for
/// comparison at each stage is generated by the `next_cmp` function, and once
/// the results of that comparison are available, the struct is updated
/// using the `update` function.  After the search is completed, the resulting
/// insertion index is retrieved with a call to `result`.
///
/// Comparison pairs are specified for comparison with a "strict less than"
/// operation by default, and for this interpretation, the resulting index
/// places the query after all elements "less than or equal to" the value, and
/// before all elements "greater than" the value.
pub struct BinarySearch<'a, Value: Clone> {
    /// Index of left endpoint of search interval, inclusive
    left: usize,

    /// Index of right endpoint of search interval, exclusive
    right: usize,

    /// Query value for which we want the insertion index
    query: &'a Value,

    /// Reference to sorted array of values to which indexes refer
    arr: &'a [Value],
}

impl<'a, Value: Clone> BinarySearch<'a, Value> {
    /// Generate the initial state for a binary search for a query over the full
    /// range of a given sorted array.
    pub fn new(query: &'a Value, arr: &'a [Value]) -> Self {
        BinarySearch::new_in_range(0, arr.len(), query, arr)
    }

    /// Generate the initial state for a binary search for a query of a
    /// specified interval within a given sorted array.
    pub fn new_in_range(left: usize, right: usize, query: &'a Value, arr: &'a [Value]) -> Self {
        debug_assert!(left <= right && right <= arr.len());
        Self {
            left,
            right,
            query,
            arr,
        }
    }

    /// Update the given binary search with comparison result `cmp_result`
    /// describing the outcome of `query < arr[middle]`.
    pub fn update(&mut self, cmp_result: bool) {
        let middle = midpoint(self.left, self.right);
        if cmp_result {
            self.right = middle;
        } else {
            self.left = middle + 1;
        }
    }

    /// Returns whether the binary search has converged to an insertion index.
    pub fn is_finished(&self) -> bool {
        self.left >= self.right
    }

    /// If additional comparisons are needed, returns the pair of values
    /// `(query, arr[middle])` to be compared for the next step of the search.
    /// Returned values are cloned from their sources.
    ///
    /// A `Some` value indicates that additional comparisons are needed, and a
    /// `None` value indicates that search has already converged to a result.
    pub fn next_cmp(&self) -> Option<(Value, Value)> {
        if self.is_finished() {
            None
        } else {
            let middle = midpoint(self.left, self.right);
            Some((self.query.clone(), self.arr[middle].clone()))
        }
    }

    /// Returns `Some(insertion_index)` if the search has converged to a result.
    /// Otherwise, returns `None`.
    pub fn result(&self) -> Option<usize> {
        if self.is_finished() {
            Some(self.left)
        } else {
            None
        }
    }
}
